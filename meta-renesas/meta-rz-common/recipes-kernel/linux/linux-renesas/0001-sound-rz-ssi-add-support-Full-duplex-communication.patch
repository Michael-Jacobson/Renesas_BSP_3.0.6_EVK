From 81439d0e694e014b37475364eca7d0fdcabaee27 Mon Sep 17 00:00:00 2001
From: hienhuynh <hien.huynh.px@renesas.com>
Date: Mon, 18 Dec 2023 16:34:56 +0700
Subject: [PATCH 1/2] sound: rz-ssi: add support Full duplex communication

SSI of RZ/G2L Series can support Full duplex communication.
To support it, we have to:
- Enable REN and TEN bits at the same time.
- Disable DMA mode. Currently only support with PIO mode.
- Playback must run before capturing due to HW description.
- HW parameters should be identical for both playback and capture.

Signed-off-by: hienhuynh <hien.huynh.px@renesas.com>
---
 sound/soc/sh/rz-ssi.c | 278 ++++++++++++++++++++++++++----------------
 1 file changed, 176 insertions(+), 102 deletions(-)

diff --git a/sound/soc/sh/rz-ssi.c b/sound/soc/sh/rz-ssi.c
index 0caff4dadbcb..80a3febb565b 100644
--- a/sound/soc/sh/rz-ssi.c
+++ b/sound/soc/sh/rz-ssi.c
@@ -134,6 +134,17 @@ struct rz_ssi_priv {
 	bool lrckp_fsync_fall;	/* LR clock polarity (SSICR.LRCKP) */
 	bool bckp_rise;	/* Bit clock polarity (SSICR.BCKP) */
 	bool dma_rt;
+
+	/* Full duplex communication support */
+	bool is_full_duplex;
+	int power_count;
+
+	struct {
+		unsigned int rate;
+		unsigned int channels;
+		unsigned int sample_width;
+		unsigned int sample_bits;
+	} hw_params_saved;
 };
 
 static void rz_ssi_dma_complete(void *data);
@@ -330,7 +341,8 @@ static int rz_ssi_start(struct rz_ssi_priv *ssi, struct rz_ssi_stream *strm)
 	u32 ssicr, ssifcr;
 
 	ssicr = rz_ssi_reg_readl(ssi, SSICR);
-	ssifcr = rz_ssi_reg_readl(ssi, SSIFCR) & ~0xF;
+	ssifcr = rz_ssi_reg_readl(ssi, SSIFCR);
+	ssifcr &= (ssi->is_full_duplex) ? (~0x3) : (~0xF);
 
 	/* FIFO interrupt thresholds */
 	if (rz_ssi_is_dma_enabled(ssi))
@@ -343,13 +355,14 @@ static int rz_ssi_start(struct rz_ssi_priv *ssi, struct rz_ssi_stream *strm)
 	/* enable IRQ */
 	if (is_play) {
 		ssicr |= SSICR_TUIEN | SSICR_TOIEN;
-		ssifcr |= SSIFCR_TIE | SSIFCR_RFRST;
+		ssifcr |= SSIFCR_TIE |
+			  ((ssi->is_full_duplex) ? 0 : SSIFCR_RFRST);
 	} else {
 		ssicr |= SSICR_RUIEN | SSICR_ROIEN;
-		ssifcr |= SSIFCR_RIE | SSIFCR_TFRST;
+		ssifcr |= SSIFCR_RIE |
+			  ((ssi->is_full_duplex) ? 0 : SSIFCR_TFRST);
 	}
 
-	rz_ssi_reg_writel(ssi, SSICR, ssicr);
 	rz_ssi_reg_writel(ssi, SSIFCR, ssifcr);
 
 	/* Clear all error flags */
@@ -358,9 +371,13 @@ static int rz_ssi_start(struct rz_ssi_priv *ssi, struct rz_ssi_stream *strm)
 			      SSISR_RUIRQ), 0);
 
 	strm->running = 1;
-	ssicr |= is_play ? SSICR_TEN : SSICR_REN;
+	ssicr |= (ssi->is_full_duplex) ? (SSICR_TEN | SSICR_REN) :
+		 (is_play ? SSICR_TEN : SSICR_REN);
+
 	rz_ssi_reg_writel(ssi, SSICR, ssicr);
 
+	ssi->power_count++;
+
 	return 0;
 }
 
@@ -369,39 +386,42 @@ static int rz_ssi_stop(struct rz_ssi_priv *ssi, struct rz_ssi_stream *strm)
 	int timeout;
 
 	strm->running = 0;
+	ssi->power_count--;
 
-	/* Disable TX/RX */
-	rz_ssi_reg_mask_setl(ssi, SSICR, SSICR_TEN | SSICR_REN, 0);
-
-	/* Cancel all remaining DMA transactions */
-	if (rz_ssi_is_dma_enabled(ssi))
-		dmaengine_terminate_async(strm->dma_ch);
+	if (!ssi->power_count) {
+		/* Disable TX/RX */
+		rz_ssi_reg_mask_setl(ssi, SSICR, SSICR_TEN | SSICR_REN, 0);
 
-	/* Disable irqs */
-	rz_ssi_reg_mask_setl(ssi, SSICR, SSICR_TUIEN | SSICR_TOIEN |
-			     SSICR_RUIEN | SSICR_ROIEN, 0);
-	rz_ssi_reg_mask_setl(ssi, SSIFCR, SSIFCR_TIE | SSIFCR_RIE, 0);
+		/* Cancel all remaining DMA transactions */
+		if (rz_ssi_is_dma_enabled(ssi))
+			dmaengine_terminate_async(strm->dma_ch);
+
+		/* Disable irqs */
+		rz_ssi_reg_mask_setl(ssi, SSICR, SSICR_TUIEN | SSICR_TOIEN |
+				     SSICR_RUIEN | SSICR_ROIEN, 0);
+		rz_ssi_reg_mask_setl(ssi, SSIFCR, SSIFCR_TIE | SSIFCR_RIE, 0);
+
+		/* Clear all error flags */
+		rz_ssi_reg_mask_setl(ssi, SSISR,
+				     (SSISR_TOIRQ | SSISR_TUIRQ | SSISR_ROIRQ |
+				      SSISR_RUIRQ), 0);
+
+		/* Wait for idle */
+		timeout = 100;
+		while (--timeout) {
+			if (rz_ssi_reg_readl(ssi, SSISR) & SSISR_IIRQ)
+				break;
+			udelay(1);
+		}
 
-	/* Clear all error flags */
-	rz_ssi_reg_mask_setl(ssi, SSISR,
-			     (SSISR_TOIRQ | SSISR_TUIRQ | SSISR_ROIRQ |
-			      SSISR_RUIRQ), 0);
+		if (!timeout)
+			dev_info(ssi->dev, "timeout waiting for SSI idle\n");
 
-	/* Wait for idle */
-	timeout = 100;
-	while (--timeout) {
-		if (rz_ssi_reg_readl(ssi, SSISR) & SSISR_IIRQ)
-			break;
-		udelay(1);
+		/* Hold FIFOs in reset */
+		rz_ssi_reg_mask_setl(ssi, SSIFCR, 0,
+				     SSIFCR_TFRST | SSIFCR_RFRST);
 	}
 
-	if (!timeout)
-		dev_info(ssi->dev, "timeout waiting for SSI idle\n");
-
-	/* Hold FIFOs in reset */
-	rz_ssi_reg_mask_setl(ssi, SSIFCR, 0,
-			     SSIFCR_TFRST | SSIFCR_RFRST);
-
 	return 0;
 }
 
@@ -556,53 +576,72 @@ static irqreturn_t rz_ssi_interrupt(int irq, void *data)
 	struct rz_ssi_priv *ssi = data;
 	u32 ssisr = rz_ssi_reg_readl(ssi, SSISR);
 
-	if (ssi->playback.substream)
-		strm = &ssi->playback;
-	else if (ssi->capture.substream)
-		strm = &ssi->capture;
-	else
-		return IRQ_HANDLED; /* Left over TX/RX interrupt */
-
-	if (irq == ssi->irq_int) { /* error or idle */
-		if (ssisr & SSISR_TUIRQ)
-			strm->uerr_num++;
-		if (ssisr & SSISR_TOIRQ)
-			strm->oerr_num++;
-		if (ssisr & SSISR_RUIRQ)
-			strm->uerr_num++;
-		if (ssisr & SSISR_ROIRQ)
-			strm->oerr_num++;
-
-		if (ssisr & (SSISR_TUIRQ | SSISR_TOIRQ | SSISR_RUIRQ |
-			     SSISR_ROIRQ)) {
-			/* Error handling */
-			/* You must reset (stop/restart) after each interrupt */
-			rz_ssi_stop(ssi, strm);
-
-			/* Clear all flags */
-			rz_ssi_reg_mask_setl(ssi, SSISR, SSISR_TOIRQ |
-					     SSISR_TUIRQ | SSISR_ROIRQ |
-					     SSISR_RUIRQ, 0);
-
-			/* Add/remove more data */
-			strm->transfer(ssi, strm);
-
-			/* Resume */
-			rz_ssi_start(ssi, strm);
+	if (!(ssi->is_full_duplex)) {
+		if (ssi->playback.substream)
+			strm = &ssi->playback;
+		else if (ssi->capture.substream)
+			strm = &ssi->capture;
+		else
+			return IRQ_HANDLED; /* Left over TX/RX interrupt */
+
+		if (irq == ssi->irq_int) { /* error or idle */
+			if (ssisr & SSISR_TUIRQ)
+				strm->uerr_num++;
+			if (ssisr & SSISR_TOIRQ)
+				strm->oerr_num++;
+			if (ssisr & SSISR_RUIRQ)
+				strm->uerr_num++;
+			if (ssisr & SSISR_ROIRQ)
+				strm->oerr_num++;
+
+			if (ssisr & (SSISR_TUIRQ | SSISR_TOIRQ | SSISR_RUIRQ |
+				     SSISR_ROIRQ)) {
+				/* Error handling */
+				/* You must reset (stop/restart) after each interrupt */
+				rz_ssi_stop(ssi, strm);
+	
+				/* Clear all flags */
+				rz_ssi_reg_mask_setl(ssi, SSISR, SSISR_TOIRQ |
+						     SSISR_TUIRQ | SSISR_ROIRQ |
+						     SSISR_RUIRQ, 0);
+
+				/* Add/remove more data */
+				strm->transfer(ssi, strm);
+
+				/* Resume */
+				rz_ssi_start(ssi, strm);
+			}
 		}
-	}
 
-	if (!strm->running)
-		return IRQ_HANDLED;
+		if (!strm->running)
+			return IRQ_HANDLED;
 
-	/* tx data empty */
-	if (irq == ssi->irq_tx)
-		strm->transfer(ssi, &ssi->playback);
+		/* tx data empty */
+		if (irq == ssi->irq_tx)
+			strm->transfer(ssi, &ssi->playback);
 
-	/* rx data full */
-	if (irq == ssi->irq_rx) {
-		strm->transfer(ssi, &ssi->capture);
-		rz_ssi_reg_mask_setl(ssi, SSIFSR, SSIFSR_RDF, 0);
+		/* rx data full */
+		if (irq == ssi->irq_rx) {
+			strm->transfer(ssi, &ssi->capture);
+			rz_ssi_reg_mask_setl(ssi, SSIFSR, SSIFSR_RDF, 0);
+		}
+
+	} else {
+		/* tx data empty */
+		if (irq == ssi->irq_tx && ssi->playback.substream) {
+			strm = &ssi->playback;
+			if (strm->running)
+				strm->transfer(ssi, &ssi->playback);
+		}
+
+		/* rx data full */
+		if (irq == ssi->irq_rx && ssi->capture.substream) {
+			strm = &ssi->capture;
+			if (strm->running) {
+				strm->transfer(ssi, &ssi->capture);
+				rz_ssi_reg_mask_setl(ssi, SSIFSR, SSIFSR_RDF, 0);
+			}
+		}
 	}
 
 	return IRQ_HANDLED;
@@ -740,6 +779,9 @@ static int rz_ssi_dma_request(struct rz_ssi_priv *ssi, struct device *dev)
 	if (!rz_ssi_is_dma_enabled(ssi))
 		goto no_dma;
 
+	if (ssi->is_full_duplex)
+		goto no_dma;
+
 	return 0;
 
 no_dma:
@@ -758,9 +800,11 @@ static int rz_ssi_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 		/* Soft Reset */
-		rz_ssi_reg_mask_setl(ssi, SSIFCR, 0, SSIFCR_SSIRST);
-		rz_ssi_reg_mask_setl(ssi, SSIFCR, SSIFCR_SSIRST, 0);
-		udelay(5);
+		if (!ssi->power_count) {
+			rz_ssi_reg_mask_setl(ssi, SSIFCR, 0, SSIFCR_SSIRST);
+			rz_ssi_reg_mask_setl(ssi, SSIFCR, SSIFCR_SSIRST, 0);
+			udelay(5);
+		}
 
 		rz_ssi_stream_init(strm, substream);
 
@@ -803,6 +847,7 @@ static int rz_ssi_dai_trigger(struct snd_pcm_substream *substream, int cmd,
 		}
 
 		ret = rz_ssi_start(ssi, strm);
+
 		break;
 	case SNDRV_PCM_TRIGGER_STOP:
 		rz_ssi_stop(ssi, strm);
@@ -873,22 +918,43 @@ static int rz_ssi_dai_hw_params(struct snd_pcm_substream *substream,
 	unsigned int sample_bits = hw_param_interval(params,
 					SNDRV_PCM_HW_PARAM_SAMPLE_BITS)->min;
 	unsigned int channels = params_channels(params);
+	unsigned int sample_width = params_width(params);
+	unsigned int rate = params_rate(params);
+	int ret;
 
-	ssi->sample_width = params_width(params);
-	if ((sample_bits != 16) && (ssi->sample_width == 16)) {
-		dev_err(ssi->dev, "Unsupported sample width: %d\n",
-			sample_bits);
-		return -EINVAL;
-	}
+	if (!ssi->power_count) {
+		ssi->sample_width = sample_width;
+		if ((sample_bits != 16) && (ssi->sample_width == 16)) {
+			dev_err(ssi->dev, "Unsupported sample width: %d\n",
+				sample_bits);
+			return -EINVAL;
+		}
 
-	if (channels != 2) {
-		dev_err(ssi->dev, "Number of channels not matched: %d\n",
-			channels);
-		return -EINVAL;
+		if (channels != 2) {
+			dev_err(ssi->dev, "Number of channels not matched: %d\n",
+				channels);
+			return -EINVAL;
+		}
+
+		ret = rz_ssi_clk_setup(ssi, rate, channels);
+		if (ret)
+			return ret;
+
+		ssi->hw_params_saved.rate = params_rate(params);
+		ssi->hw_params_saved.channels = channels;
+		ssi->hw_params_saved.sample_width = params_width(params);
+		ssi->hw_params_saved.sample_bits = sample_bits;
+	} else {
+		if ((ssi->hw_params_saved.rate != rate) ||
+		    (ssi->hw_params_saved.channels != channels) ||
+		    (ssi->hw_params_saved.sample_width != sample_width) ||
+		    (ssi->hw_params_saved.sample_bits != sample_bits)) {
+			dev_err(ssi->dev, "Full duplex needs same HW params\n");
+			return -EINVAL;
+		}
 	}
 
-	return rz_ssi_clk_setup(ssi, params_rate(params),
-				params_channels(params));
+	return 0;
 }
 
 static const struct snd_soc_dai_ops rz_ssi_dai_ops = {
@@ -1008,6 +1074,10 @@ static int rz_ssi_probe(struct platform_device *pdev)
 				     "no audio clk1 or audio clk2");
 
 	ssi->audio_mck = ssi->audio_clk_1 ? ssi->audio_clk_1 : ssi->audio_clk_2;
+	ssi->is_full_duplex = device_property_read_bool(&pdev->dev,
+							"full-duplex");
+	if (ssi->is_full_duplex)
+		dev_info(&pdev->dev, "Full duplex communication enabled");
 
 	/* Detect DMA support */
 	ret = rz_ssi_dma_request(ssi, &pdev->dev);
@@ -1027,19 +1097,21 @@ static int rz_ssi_probe(struct platform_device *pdev)
 	spin_lock_init(&ssi->lock);
 	dev_set_drvdata(&pdev->dev, ssi);
 
-	/* Error Interrupt */
-	ssi->irq_int = platform_get_irq_byname(pdev, "int_req");
-	if (ssi->irq_int < 0) {
-		rz_ssi_release_dma_channels(ssi);
-		return ssi->irq_int;
-	}
+	if (!(ssi->is_full_duplex)) {
+		/* Error Interrupt */
+		ssi->irq_int = platform_get_irq_byname(pdev, "int_req");
+		if (ssi->irq_int < 0) {
+			rz_ssi_release_dma_channels(ssi);
+			return ssi->irq_int;
+		}
 
-	ret = devm_request_irq(&pdev->dev, ssi->irq_int, &rz_ssi_interrupt,
-			       0, dev_name(&pdev->dev), ssi);
-	if (ret < 0) {
-		rz_ssi_release_dma_channels(ssi);
-		return dev_err_probe(&pdev->dev, ret,
-				     "irq request error (int_req)\n");
+		ret = devm_request_irq(&pdev->dev, ssi->irq_int, &rz_ssi_interrupt,
+				       0, dev_name(&pdev->dev), ssi);
+		if (ret < 0) {
+			rz_ssi_release_dma_channels(ssi);
+			return dev_err_probe(&pdev->dev, ret,
+					     "irq request error (int_req)\n");
+		}
 	}
 
 	if (!rz_ssi_is_dma_enabled(ssi)) {
@@ -1089,6 +1161,8 @@ static int rz_ssi_probe(struct platform_device *pdev)
 		goto err_snd_soc;
 	}
 
+	ssi->power_count = 0;
+
 	return 0;
 
 err_snd_soc:
-- 
2.25.1

